### 6. 타인을 사칭한 공격
#### 사이트간 요청 위조 CRSF(Cross Site Request Forgeries)
- 게시판에 등록할 떄 사용자는 웹 서버가 제공하는 양식을 이용하여 입력하게 된다.
- 일반적인 경우에 입력한 내용을 확인하는 화면을 나타나고, 시스템은 이용자가 확인하는 화면에서 동의한 내용만 받아들이도록 되어있다.
- 그러나 이와 관련해 적절한 점검이 수행되지 않았다면, 악의적인 프로그램을 이용하여 직접 등록할 수 있게 되는데 이를 사이트간 요청 위조(CSRF Cross Site Request Forgeries)라고 한다.
- CSRF
  - 특정 요청을 브라우저의 요청 없이 임의로 요청을 함으로 특정 프로세스를 수행할 수 있다.
  - 예를 들어 다른 사이트에 준비했던 링크를 클릭할 수 있어서 이용자가 게시물의 내용을 확인하는 화면 없이 게시판에 임의의 내용이 게시되도록 할 수 있다.
  - 구체적으로는 인터넷 쇼핑에서 임의로 제품을 구입하거나, 게시판에 범행을 예고하는 게시물을 올릴 수 있게 된다.
  - 공격기법으로 공격자가 작업한 웹 사이트에 접속하도록 DM(Direct Mail, 상품광고를 위해 특정 고객층 앞으로 직접 우송하는 서신이나 카탈로그 등의 인쇄물)으로 연락하는 방법이 사용
  - 이 URL로 접속하면 공격자가 작성한 스크립트가 실행되어 조작이 발생하는 형식이다.
- 개발자로서 대책을 제시할 때 검증용 데이터를 함께 전송하고, 검증용 데이터를 확인하는 방법을 이용하고 있다.
```
사이트간 요청 위조 시나리오
1. 공격자가 공격 대상 서버에 스크립트를 심어둠
2. 이용자는 해당 서버에 브라우저를 통해 요청하고
 스크립트를 포함한 응답을 받는다
3. 해당 스크립트를 실행한다.
4. 스크립트에 포함된 액티브를 실행하게 된다.(자동으로 게시 액티브)
5. 자동으로 게시 완료
```

#### 이용자 측면의 대책인 로그아웃
- 위에서 기술한 취약점이 SNS등의 서비스에 존재한다고 하면, 로그인한 기간 동안에는 언제든지 악성 게시물을 올릴 수 있는 상태가 되어버린다.
- 귀찮더라도 필요한 작업이 끝나면 로그아웃 하는 습관을 익혀 두는 것이 좋다.
- 이 취약점은 서비스 제공자가 대책을 수립하는 것을 전제로 하지만, 피해를 예방하는 의미에서 이용자는 로그아웃 하는 것 외에도 의심스러운 링크를 클릭하지 않는 것이 중요하다.
- 또한 이러한 게시물을 올리게 되면 뉴스가 되어버리는 경우가 많기 때문에, 최근의 정보 동향에도 주의를 기울이지 않으면 안된다.
```
사이트간 요청 위조 예방 조치 시나리오
1. 요청
2. 검증용 데이터가 포함된 양식(Form) 응답
  CSRF를 막기 위해, 양식을 게시하기 전 검증용 데이터 체크 실시
  1. 이때 공격자가 검증용 데이터 없이 전송
  2. 검증용 데이터가 일치하지 않아 게시 실패
3. 검증용 데이터와 함께 전송
4. 검증용 데이터가 일치하면 게시 완료
```

#### Point
- 사이트간 요청 위조(CSRF) 취약점이 있는 경우, 이용자가 모르는 상태에서 임의의 게시물이 게시되거나, 제품을 구입하게 될 것
- 서비스 제공자 측면에서 입력 양식에 검증용 데이터를 포함시키는 등 대책을 마련해야 한다.
- 이용자의 예방 대책으로 로그인을 해야 하는 서비스는 필요한 작업이 끝난 후 로그아웃 하는 것도 효과적이다.

### 7. 로그인 상태 가로채기
#### 동일한 이용자를 식별하는 세션의 구조
- 쇼핑 사이트 등을 이용할 떄, 한 번 로그인 하면 다른 페이지로 전환해도 로그인 상태가 유지되고 있다.
- 그런데 웹 브라우저에서 사용되는 HTTP라는 프로토콜을 여러 페이지에 걸쳐 동일한 이용자임을 확인하는 방법이 없다.
- 따라서 웹 브라우저가 웹 서버 사이 동일한 이용자를 식별하기 위해 Cookie라는 값을 매번 보내는 방법과 URL에 파라미터(Parameter)를 전달하는 방법, 숨겨진 필드를 사용하는 방법 등이 사용된다.
- 이와 같이 이용자를 식별하기 위해 사용되는 구조를 세션(Session)이라고 한다.
- 그러나 이 세션을 관리하는 방법을 악용하면 다른 사람인 척 행세할 수 있게 되어버린다.

```
세션의 구조
세션 관리가 없는 경우
- 사용자가 브라우저로 첫번쨰 접속시 사용자로 인식
- 두번째 접속해도 다른 사용자로 인식

1. 쿠키를 이용한 관리
- 첫번째 접속 시 해당 컴퓨터에 쿠키정보를 붙여 보냄
- 두번쨰 접속시 쿠키정보를 보내 저장되어 있는 쿠키 정보로 사용자를 인식

2. ID정보를 붙여서 관리
- 첫번쨰 접속 시 해당 컴퓨터에 ID정보를 붙여 보냄
- 두번쨰 접속시 URL에 ID정보를 보내 사용자 정보를 확인한다.

3. 숨겨진 양식에 ID를 포함
- 첫번쨰 접속 시 해당 컴퓨터 숨겨진 양식에 ID정보를 세팅
- 두번쨰 접속 시 숨겨진 양식에 세팅된 정보를 서버로 보내 사용자 인식.

상기 방법들은 어떻게든 해킹을 당한다.
```

#### 다른 사람의 세션을 가로채기
- 웹에서 사용되는 HTTP는 암호화되어 있지 않아서, 위에서 기술한 어떠한 방법을 사용해도 세션 정보를 도둑 맞으면 쉽게 조작이 가능하다.
- 세션정보를 수정하여 다른 이용자가 사용중인 응용 프로그램을 빼앗는 것을 세션 하이제킹이라고 한다.
- 세션 하이재킹 
  - 이용자가 웹 어플리케이션에 로그인할 때 발행되는 "세션ID"를 공격자가 부정하게 취득하는 것으로, 이용자를 사칭하는 공격.
  - 비밀번호를 몰라도 다른 사람을 사칭하는 것이 가능하다.
- 세션 하이재킹의 수법
  - 숄더 해킹
  - 규칙성을 사용한 추측
  - 크로스 사이트 스크립팅
  - 리퍼러 사용
    - HTTP referrer, 호출자(Link 원본)의 URL정보, 웹 브라우저로 웹을 서핑할 때, 하이퍼 링크를 통해서 각각의 사이트로 방문시 남는 흔적
  - 패킷 도청
- 예를 들어 URL 파라미터에 세션 ID가 지정되어 있는 경우, 전환 대상 웹 사이트 관리자가 브라우저로 전송되어오는 리퍼러 정보를 열람하여 세션ID를 알 수 있다.

#### Point
- 세션 하이재킹이 발생하면 다른 사람 행세를 하면서 웹 상에서 서비스를 이용할 수 있다.
- 추측할 수 없도록 임의의 값(Random 값)을 세션 ID로 사용하거나 HTTPS를 이용한 암호화가 요구된다.

### 8. 메모리 영역의 초과를 악용
#### 프로그램 실행 시 확보된 메모리 영역
- 프로그램을 실행하면 컴퓨터의 내부에는 임시 저장에 필요한 공간이 컴퓨터 메모리에 유지된다.
- 여기에는 프로그램에서 입력된 데이터도 저장되지만, 입력 데이터의 크기가 너무 크면 설계 시 설정된 영역을 넘겨서 저장하게 되는 상황도 발생한다.
- 개발자가 프로그램을 개발 할 떄 이 크기를 확인하고 초과되지 않도록 제한하고 있다면 문제가 없겠지만 그렇지 않은 경우에는 입력하면서 임의의 문자열을 이 영역에 저장하게 될 가능성이 있다.
- 만약 공격자가 악의적인 코드를 작성하는 경우 임의의 프로그램이 실행 가능한 상태가 된다.
- 메모리의 구성(출처 : TCP스쿨)
<img src="./image/memory.png">

#### 확보된 공간을 초과할 떄 발생하는 문제
- C나 C++등의 프로그래밍 언어로 개발 된 프로그램은 메모리의 사용을 프로그래머가 적절하게 관리 해야 한다.
- 제대로 관리되지 않는 경우 스택오버플로우 (Stack Overflow), 힙 오버플로우(heap Overflow), 정수 오버플로우(Check Overflow)등이 발생하는데 이것들은 버퍼 오버플로우(Buffer Overflow)의 일종이다.
- 미리 정해져 있는 영역을 초과하여 접속함으로 써 발생하는 것
- 버퍼 오버 플로우가 있는 상태, 즉 준비된 영역을 넘어서까지 쓰기 가능한 상태가 되어 있으면, 앞에서 기술한 바와 같이 공격자가 제공한 악의적인 코드를 실행 시킬 수 있다.
- 최근의 웹 어플리케이션은 JAVA나 PHP, Ruby 같은 프로그래밍 언어로 구현되는 경우가 많으며, 이러한 언어로 작성된 프로그램에서 메모리 사용에 의한 취약점은 거의 발생하지 않는다.
- 그러나 이러한 언어를 사용하는 프레임워크 및 미들웨어 중에는 C나 C++등으로 개발되어 있으므로 주의가 필요하다.

#### Point
- 메모리 사용을 프로그래머가 관리해야 하는 프로그래밍 언어를 사용한다면, 버퍼 오버플로우 취약점이 발생할 가능성이 있다.
- 최근의 스크립트 언어에서는 메모리 사용에 의한 취약점은 거의 발생하지 않지만, 내부에서 진행되는 처리에 취약점이 남아 있을 수 있다.